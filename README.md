# 基本アイデア
範囲内の値集合に関する一致判定が重要なので、ZobristHashだろう。

## ツアーパスの構築
目的地間は最短距離で移動するのでいいだろう。余計な迂回路のハンドリングは難しい。
強いていえば過去に通過した回数が多い道を好むくらいか。
その場合でも、目的地との距離が増加するようなことはあってはならない。

## 辞書$A$の構築
移動ごとに毎回信号を切り替える非効率なツアーを基準に考えると、確定したツアー内の区間集合と$A$の連続部分列区間集合が一致することの相対的な嬉しさは、$(ツアー内区間の長さ - 1) \times 全ツアーパス内の出現回数$でざっくり見積れるだろう。なので
1. ツアー内の区間を$O(N^2)$で全探索して、その集合Hashの出現回数を数え上げ、上記の指標で降順ソートする。
1. ソート先頭から$A$に登録していく。
1. ツアーパス内に出現する頂点番号はすべて出現させたい。容量ギリギリになってきたら未登場の頂点番号を詰め込んでいく。

## 実際のプランニング
ツアーパスと辞書を固定すると、最適なプランニングはDPで求まる。
辞書内の任意の連続区間であって、長さ$L_B$の範囲には、必ず値重複がないという仮定のもとで

1. 事前に辞書内の長さ$L_b$以下の区間について、集合のHash値を求め、Setに格納しておく。計算量は$O(N\ L_B)$。
1. $DP[i]$を、ツアー内の$i$番目の地点へ到達するまでに必要な最小の信号変更回数とする。$i$から$j(i<j)$への繊維が可能かどうかは、区間$(i, j]$内に存在する頂点番号のHash値が辞書内に存在すること。計算量は$O(N^2)$
1. BackTraceによる実際のツアープロセス復元。
